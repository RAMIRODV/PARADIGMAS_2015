En todos estos test nos basamos en el libro Concepts in Programming Language
de la pagina 177 con el siguiente ejemplo:

int x = 1;
function g(z) = x+z;
function f(y) = {
    int x = y+1;
    return g(y*x);
};
f(3);

Lenguaje C
----------
Con el siguiente codigo vamos a ver que nos devuelve C luego de compilar.

#include <stdio.h>

char x[] = "estatico";

void g(void) {
    printf("C tiene alcance: %s\n", x);
}

void f(void) {
    char x[] = "dinamico";
    g();
}

int main(void) {
    f();
    return 0;
}

Al ser compilado y ejecutado este codigo, nos imprimio que C es un lenguaje
con alcance estatico. Por lo tanto llegamos a esta conclusion.

Lenguaje Scala
--------------
Con el siguiente codigo vamos a ver que nos devuelve Scala.

object Main extends App {
    var x = "estatico"
    def g() = {
        println(s"Escala es de alcance: $x")
    }
    
    def f() = {
        var x = "dinamico"
        g()
    }
    f()
}
Luego de compilar y ejecutar este codigo, Scala nos imprime que es de alcance
estatico. Por lo tanto llegamos a esta conclusion.

Lenguaje JavaScript
-------------------
Con el siguiente codigo vamos a ver que nos devuelve JavaScript

<script type="text/javascript">
var x = "estatico";
function g() {
    alert("JavaScript es: " + x);
}
function f() {
    var x = "dinamico";
    g();
}
f();
</script>

Luego de ejectuar este codigo Javascript nos dice que es de alcance estatico.
Por lo tanto llegamos a esta conclusion.

Lenguaje Ruby
-------------
En este lenguaje hay formas de declarar variables globales, entre ellas esta
el "$" y otro de alcance en class "@".
En el codigo de prueba esta lo siguiente:

$x = "estatico"
def g()
    print $x  <-- Aqui estamos usando la variable global
end
def f()
    $x = "dinamico"  <-- Aqui estamos modificando la variable global
    g()
end

f()

Lo cual el resultado es: "dinamico", esto tiene sentido ya que vamos modificando
la variable global. Por lo tanto en este caso se podria concluir que Ruby tiene
alcance dinamico.

Pero hay algunas curiosidades como en el siguiente codigo:

Ejemplo 1

var=2

def f()
   var = 6  <-- Modifico supuestamente la "variable" var.
end

f()
print var

Esto imprime: 2, y con esto se podria concluir que Ruby es de alcance estatico.
Pero hemos analizado un poco mas e hicimos otro codigo:

Ejemplo 2

var=2
def g()
    print var
end
def f()
   var = 6
   g()
end
f()

Aqui al ejecutar f() lanza un error (no sabemos que tipo ya que compilamos y
usamos la pagina web ideone.com y solo nos devuelve return -1). El error es
producido cuando se ejecuta g(). Al entrar a este procedimiento, trata de
imprimir var; para ruby el var=2 externo no tiene alcance en este procedimiento
es decir, desconoce esa variable, por eso emite un error. Por lo tanto se puede
decir que var=2 no es "global" a todos los procedimientos/funciones.
Es por ello que hicimos uso del "$" para definir las variables globales.

Conclusion
Ruby tiene un modo de manejar los alcances de variables, los cuales son:
de alcance local, alcance global, alcance de instancia y alcance de clase.
Estos dos ultimos no lo probamos pero nos basamos en la pagina:
http://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Operators#Default_scope
Por lo tanto, usando la variable global podemos decir que Ruby tiene alcance
dinamico.
